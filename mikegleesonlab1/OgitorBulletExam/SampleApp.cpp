/*
-----------------------------------------------------------------------------
Filename:    SampleApp.cpp
-----------------------------------------------------------------------------


This source file is generated by the
___                   _              __    __ _                  _ 
/___\__ _ _ __ ___    /_\  _ __  _ __/ / /\ \ (_)______ _ _ __ __| |
//  // _` | '__/ _ \  //_\\| '_ \| '_ \ \/  \/ / |_  / _` | '__/ _` |
/ \_// (_| | | |  __/ /  _  \ |_) | |_) \  /\  /| |/ / (_| | | | (_| |
\___/ \__, |_|  \___| \_/ \_/ .__/| .__/ \/  \/ |_/___\__,_|_|  \__,_|
|___/                 |_|   |_|                                 
Ogre 1.7.x Application Wizard for VC9 (January 2010)
http://code.google.com/p/ogreappwizards/
-----------------------------------------------------------------------------
*/

#include "SampleApp.h"
#include "DotSceneLoader.h"
#include "XInputManager.h"

#define OGRE_PLATFORM OGRE_PLATFORM_WIN32
//#include "PAGEDGEOMETRY/PagedGeometry.h"
//#include "PAGEDGEOMETRY/GrassLoader.h"
//#include "PAGEDGEOMETRY/BatchPage.h"
//#include "PAGEDGEOMETRY/ImpostorPage.h"
//#include "PAGEDGEOMETRY/TreeLoader3D.h"
namespace Globals
{
	btDynamicsWorld *phyWorld;
	BtOgre::DebugDrawer *dbgdraw;
}


//#define MAX_LAYERS_ALLOWED 6
static Ogre::String CurrentScene = "testing.scene";
static Ogre::SceneNode* playerNode;
static Ogre::Entity* player;
static Ogre::AnimationState* _aniState;
static XInputManager* XboxControllers;
static Ogre::Vector3 mVelocity = Ogre::Vector3::ZERO;
static int variable =1;
static bool bFlagTest = false;
using namespace Forests;

//-------------------------------------------------------------------------------------
SampleApp::SampleApp(void)
	:    mLoader(0),
	mTerrainImported(true),
	mSceneFile(Ogre::StringUtil::BLANK),
	mHelpInfo(Ogre::StringUtil::BLANK),
	mFly(false),
	mFallVelocity(0)
{
	mCamNames.clear();

	mHelpInfo = Ogre::String("Use [W][A][S][D] keys for movement.\nKeys [1]-[9] to switch between cameras.\n[0] toggles SceneNode debug visuals.\n\nPress [C] to toggle clamp to terrain (gravity).\n\n[G] toggles the detail panel.\n[R] cycles polygonModes (Solid/Wireframe/Points).\n[T] cycles various filtering.\n\n\nPress [ESC] to quit.");
}

//-------------------------------------------------------------------------------------
SampleApp::~SampleApp(void)
{
	delete mLoader;
}

//-------------------------------------------------------------------------------------
void SampleApp::setupResources(void)
{
	// Bullet initialisation.
	mBroadphase = new btAxisSweep3(btVector3(-10000,-10000,-10000), btVector3(10000,10000,10000), 1024);
	mCollisionConfig = new btDefaultCollisionConfiguration();
	mDispatcher = new btCollisionDispatcher(mCollisionConfig);
	mSolver = new btSequentialImpulseConstraintSolver();
	XboxControllers = new XInputManager();
	Globals::phyWorld = new btDiscreteDynamicsWorld(mDispatcher, mBroadphase, mSolver, mCollisionConfig);
	Globals::phyWorld->setGravity(btVector3(0,-1.0,0));

	BaseApplication::setupResources();

	rapidxml::xml_document<> XMLDoc;    // character type defaults to char
	rapidxml::xml_node<>* XMLRoot;

	std::ifstream fp;
	fp.open("SetupConfig.xml", std::ios::in | std::ios::binary);
	Ogre::DataStreamPtr stream(OGRE_NEW Ogre::FileStreamDataStream("SetupConfig.xml", &fp, false));
	char* sampleAppConfig = strdup(stream->getAsString().c_str());
	XMLDoc.parse<0>(sampleAppConfig);
	XMLRoot = XMLDoc.first_node("SampleApp");

	Ogre::String projectDir = Ogre::String(XMLRoot->first_attribute("projectDir")->value());
	mSceneFile = Ogre::String(XMLRoot->first_attribute("scene")->value());

	// add sample project directory to the resource paths
	Ogre::ResourceGroupManager::getSingleton().addResourceLocation(
		"../" + projectDir, "FileSystem", "General");

	Ogre::ResourceGroupManager::getSingleton().addResourceLocation(
		"../" + projectDir + "/SampleScene2", "FileSystem", "General");
	Ogre::ResourceGroupManager::getSingleton().addResourceLocation(
		"../" + projectDir + "/Materials", "FileSystem", "General");
	Ogre::ResourceGroupManager::getSingleton().addResourceLocation(
		"../" + projectDir + "/Models", "FileSystem", "General");
	Ogre::ResourceGroupManager::getSingleton().addResourceLocation(
		"../" + projectDir + "/Terrain", "FileSystem", "General");
}


//-------------------------------------------------------------------------------------
void SampleApp::createScene(void)
{
	mImpulse = btVector3(0,0,0);
	mLoader = new DotSceneLoader();
	mLoader->parseDotScene(mSceneFile, "General", mSceneMgr,0,"",Globals::phyWorld);

	// Get rid of the initial camera
	mSceneMgr->destroyCamera(mCamera);

	//ENTITY DECLARATIONS
	//Ogre::Light* myLight = mSceneMgr->createLight("myLight");
	//myLight->setPosition(Ogre::Vector3(0,0,20));
	//myLight->setDiffuseColour(Ogre::ColourValue(1.0,0.0,0.0,1.0));
	//Ogre::SceneNode* myNode = static_cast<Ogre::SceneNode*>(mSceneMgr->getRootSceneNode()->createChild());
	//Ogre::BillboardSet* mySet = mSceneMgr->createBillboardSet("mySet");
	//Ogre::Billboard* myBillboard = mySet->createBillboard(Ogre::Vector3(0, 0, 25));
	//myNode->attachObject(mySet);
	//myNode->scale(0.1,0.1,0.1);
	//mySet->setMaterialName("Examples/OgreLogo");

	//Ogre::ParticleSystem* particleSystemA;

	//particleSystemA = mSceneMgr->createParticleSystem("Blah2","Examples/Aureola");
	//Ogre::SceneNode* particleNodeA;
	//particleNodeA = mSceneMgr->createSceneNode();
	//mSceneMgr->getRootSceneNode()->addChild(particleNodeA);
	//particleNodeA->attachObject(particleSystemA);

	//Ogre::ParticleSystem* particleSystem;

	//particleSystem = mSceneMgr->createParticleSystem("Blah","Examples/JetEngine2");
	//Ogre::SceneNode* particleNode;
	//particleNode = mSceneMgr->createSceneNode();
	//mSceneMgr->getRootSceneNode()->addChild(particleNode);
	//particleNode->attachObject(particleSystem);
	btCollisionShape* mLeftHand = new btSphereShape(2.0);


	player = mSceneMgr->createEntity("Zombie.mesh");

	playerNode = mSceneMgr->createSceneNode();
	mSceneMgr->getRootSceneNode()->addChild(playerNode);
	playerNode->attachObject(player);
	playerNode->scale(0.1,0.1,0.1);
	playerNode->pitch(Ogre::Radian(Ogre::Degree(90.0f)));
	playerNode->setPosition(0,20,00);

	Ogre::Entity* testing;
	testing = mSceneMgr->createEntity("cube.mesh");

	player->attachObjectToBone(player->getMesh()->getSkeleton()->getBone("RootBone")->getName(),testing);
	//Create shape.
	BtOgre::AnimatedMeshToShapeConverter converter(player);
	converter.setScale(playerNode->getScale());
	//converter.addEntity(player);

	//player->getMesh()->getSkeleton()->getBone("Zombie_RightHand")->getPosition();

	mCharacterShape = converter.createConvex();//.createAlignedBox(player->getMesh()->getSkeleton()->getBone("Zombie_Hips")->getHandle(),player->getMesh()->getSkeleton()->getBone("Zombie_Hips")->getPosition(),player->getMesh()->getSkeleton()->getBone("Zombie_Hips")->getOrientation());//createCylinder(0,0,1); // Declare this btCollisionShape * pointer in SampleApp.h  

	//Calculate inertia tensor.
	btScalar mass = 5;
	btVector3 inertia;
	mCharacterShape -> calculateLocalInertia(mass, inertia);

	//Create BtOgre MotionState (connects Ogre and Bullet).
	//BtOgre::RigidBodyState *myRigidBodyState = new BtOgre::RigidBodyState(playerNode,btTransform(BtOgre::Convert::toBullet(playerNode->getOrientation()), BtOgre::Convert::toBullet(playerNode->getPosition())), btTransform(btQuaternion(),btVector3(0,0,0)));
	
	//USING OFFSET, GRAB BLANK TRANSFORM ADD IN BLANK QUATERINION AND GIVE A CONVERTED POSITION TO BULLET, PROVIDE OFFSET OF 2 (arbitrary number that worked perfectly)
	
	BtOgre::RigidBodyState *characterState = new BtOgre::RigidBodyState(playerNode,btTransform(BtOgre::Convert::toBullet(playerNode->getOrientation()), BtOgre::Convert::toBullet(playerNode->getPosition())), btTransform(btQuaternion(),btVector3(0,0,0)));
	//characterState->setWorldTransform(btTransform(btQuaternion(),BtOgre::Convert::toBullet(playerNode->getPosition()+Ogre::Vector3(0,-1,0))));
	_aniState = player->getAnimationState("Jabs");

	//Create the Body
	mCharacterBody = new btRigidBody(mass, characterState, mCharacterShape, inertia);
	mCharacterBody->setActivationState(DISABLE_DEACTIVATION);
	//mCharacterBody->getWorldTransform().setOrigin(btVector3(0,0,0));

	//mCharacterBody->getWorldTransform().setRotation(btQuaternion(btVector3(0,1,0),90.0f));
	mCharacterBody->setAngularFactor(btVector3(0,1,0));
	mCharacterBody->setLinearFactor(btVector3(1,1,0));
	Ogre::Vector3 position = playerNode->getPosition();
	//mCharacterBody->setCollisionFlags(mCharacterBody->getCollisionFlags() | btCollisionObject::CF_STATIC_OBJECT);
	// Get bullet debug lines to show using F3
	Globals::dbgdraw = new BtOgre::DebugDrawer(mSceneMgr -> getRootSceneNode(), Globals::phyWorld);
	Globals::phyWorld->setDebugDrawer(Globals::dbgdraw);
	Globals::phyWorld->addRigidBody(mCharacterBody);
	//mCharacterBody->clearForces();

	//Globals::phyWorld->setGravity(btVector3(1.1,1.8f,1.1));
	//END OF ENTITY DECLARATIONS

	// Loop through all cameras and grab their name and set their debug representation
	Ogre::SceneManager::CameraIterator cameras = mSceneMgr->getCameraIterator();
	while (cameras.hasMoreElements())
	{
		Ogre::Camera* camera = cameras.getNext();
		mCamNames.push_back(camera->getName());
		Ogre::Entity* debugEnt = mSceneMgr->createEntity(camera->getName() + Ogre::String("_debug"), "scbCamera.mesh");

		try{
			Ogre::SceneNode* sNode = mSceneMgr->getSceneNode(camera->getName());
			sNode->attachObject(debugEnt);
			sNode->scale(0.5, 0.5, 0.5);
		}catch (...){
			Ogre::SceneNode* pNode = mSceneMgr->getRootSceneNode()->createChildSceneNode(camera->getName());
			pNode->setPosition(camera->getPosition());
			pNode->setOrientation(camera->getOrientation());

			pNode->attachObject(debugEnt);
			pNode->scale(0.5, 0.5, 0.5);
		}
	}
	// Grab the first available camera, for now
	Ogre::String cameraName = mCamNames[0];
	try
	{
		mActiveCamera = mSceneMgr->getCamera(cameraName);
		mWindow->getViewport(0)->setCamera(mActiveCamera);
		mCameraMan->setCamera(mActiveCamera);
		mSceneMgr->getEntity(mActiveCamera->getName() + Ogre::String("_debug"))->setVisible(false);
		Ogre::Vector3 camPos = Ogre::Vector3(0,0,0);
		mActiveCamera->setPosition(camPos.midPoint(Ogre::Vector3(0,40,90)));
		mActiveCamera->lookAt(camPos);
		//for(unsigned int ij = 0;ij < mLoader->mPGHandles.size();ij++)
		//{
		//    mLoader->mPGHandles[ij]->setCamera(mActiveCamera);
		//}

	}
	catch (Ogre::Exception& e)
	{
		Ogre::LogManager::getSingleton().logMessage("SampleApp::createScene : setting the active camera to (\"" +
			cameraName + ") failed: " + e.getFullDescription());
	}
}

//-------------------------------------------------------------------------------------
bool SampleApp::frameRenderingQueued(const Ogre::FrameEvent& evt)
{
	bool ret = BaseApplication::frameRenderingQueued(evt);
	XboxControllers->Update();
	if(!XboxControllers->GetState(0).error) {
		// build our acceleration vector based on keyboard input composite

		Ogre::Vector3 accel = Ogre::Vector3::ZERO;
		if (XboxControllers->GetState(0).RightTrigger > 0.0) accel += mActiveCamera->getDirection();
		if (XboxControllers->GetState(0).LeftTrigger > 0.0) accel -= mActiveCamera->getDirection();
		if (XboxControllers->GetState(0).RightStick.X > 0.0) accel += mActiveCamera->getRight();
		if (XboxControllers->GetState(0).RightStick.X < 0.0) accel -= mActiveCamera->getRight();
		if (XboxControllers->GetState(0).RightStick.Y < 0.0) accel += mActiveCamera->getUp();
		if (XboxControllers->GetState(0).RightStick.Y > 0.0) accel -= mActiveCamera->getUp();

		// if accelerating, try to reach top speed in a certain time
		Ogre::Real topSpeed = XboxControllers->GetState(0).Buttons.RightThumb ? 150 * 20 : 150;
		if (accel.squaredLength() != 0)
		{
			accel.normalise();
			mVelocity += accel * topSpeed * evt.timeSinceLastFrame * 10;
		}
		// if not accelerating, try to stop in a certain time
		else mVelocity -= mVelocity * evt.timeSinceLastFrame * 10;

		Ogre::Real tooSmall = std::numeric_limits<Ogre::Real>::epsilon();

		// keep camera velocity below top speed and above epsilon
		if (mVelocity.squaredLength() > topSpeed * topSpeed)
		{
			mVelocity.normalise();
			mVelocity *= topSpeed;
		}
		else if (mVelocity.squaredLength() < tooSmall * tooSmall)
			mVelocity = Ogre::Vector3::ZERO;

		if (mVelocity != Ogre::Vector3::ZERO) mActiveCamera->move(mVelocity * evt.timeSinceLastFrame);
	}

	//if (!mFly)
	//{
	// clamp to terrain

	//Ogre::Ray ray;
	//ray.setOrigin(Ogre::Vector3(camPos.x, 10000, camPos.z));
	//ray.setDirection(Ogre::Vector3::NEGATIVE_UNIT_Y);

	//Ogre::TerrainGroup::RayResult rayResult = mLoader->getTerrainGroup()->rayIntersects(ray);
	//Ogre::Real distanceAboveTerrain = 1.4f;
	//Ogre::Real fallSpeed = 200;
	//Ogre::Real newy = camPos.y;
	//if (rayResult.hit)
	//{
	//    if (camPos.y > rayResult.position.y + distanceAboveTerrain)
	//    {
	//        mFallVelocity += evt.timeSinceLastFrame * 10;
	//        mFallVelocity = std::min(mFallVelocity, fallSpeed);
	//        newy = camPos.y - mFallVelocity * evt.timeSinceLastFrame;
	//    }
	//    newy = std::max(rayResult.position.y + distanceAboveTerrain, newy);
	//mActiveCamera->setPosition(camPos.x, camPos.y+10.0f, camPos.z);
	// }
	//}

	//if (!mLoader->getTerrainGroup()->isDerivedDataUpdateInProgress())
	//{
	//	if (mTerrainImported)
	//	{
	//		mLoader->getTerrainGroup()->saveAllTerrains(true);
	//		mTerrainImported = false;
	//	}
	//}

	mImpulse = btVector3(0,0,0);

	if(mKeyboard->isKeyDown(OIS::KC_G) && !bFlagTest)
	{
		bFlagTest = true;
		//mSceneMgr->destroyCamera(mCamera);
		//Globals::phyWorld->clearForces();
		//remove the rigidbodies from the dynamics world and delete them
		int i;
		for (i=Globals::phyWorld->getNumCollisionObjects()-1; i>=0 ;i--)
		{
			btCollisionObject* obj = Globals::phyWorld->getCollisionObjectArray()[i];
			btRigidBody* body = btRigidBody::upcast(obj);
			if (body && body->getMotionState())
			{
				delete body->getMotionState();
			}
			Globals::phyWorld->removeCollisionObject( obj );
			delete obj;
		}
		mActiveCamera->setAutoTracking(false);
		mSceneMgr->destroyAllEntities();
		mSceneMgr->destroyAllInstancedGeometry();
		mSceneMgr->destroyAllStaticGeometry();
		mSceneMgr->destroyAllManualObjects();
		mSceneMgr->destroyAllParticleSystems();
		mSceneMgr->destroyAllAnimations();
		mSceneMgr->destroyAllMovableObjects();
		mSceneMgr->destroyAllBillboardChains();
		mSceneMgr->destroyAllBillboardSets();
		mSceneMgr->destroyAllRibbonTrails();
		mSceneMgr->destroyAllLights();
		//mTerrainGroup->removeAllTerrains();

		mSceneMgr->destroyAllCameras();

		mSceneMgr->getRootSceneNode()->removeAndDestroyAllChildren();
		//Globals::phyWorld = new btDiscreteDynamicsWorld(mDispatcher, mBroadphase, mSolver, mCollisionConfig);
		//mSceneMgr->clearScene();
		//
		//mLoader = new DotSceneLoader();

		if(CurrentScene == "testing.scene")
			CurrentScene = "newtest.scene";
		else
			CurrentScene = "testing.scene";
		mTrayMgr->clearAllTrays();
		mTrayMgr->showYesNoDialog("Switch Scene", "Do you want to switch Scenes?");
		mLoader->parseDotScene(CurrentScene, "General", mSceneMgr,0,"",Globals::phyWorld);
		mActiveCamera = mSceneMgr->getCamera(Ogre::String("MainCamera"));
		mWindow->getViewport(0)->setCamera(mActiveCamera);
	} 
	else if(!mKeyboard->isKeyDown(OIS::KC_G))
	{
		bFlagTest = false;
	}
	if(mKeyboard->isKeyDown(OIS::KC_I))
		mImpulse += btVector3(0,0,1);
	if(mKeyboard->isKeyDown(OIS::KC_K))
		mImpulse += btVector3(0,0,-1);
	if(mKeyboard->isKeyDown(OIS::KC_J))
		mImpulse += btVector3(-1,0,0);
	if(mKeyboard->isKeyDown(OIS::KC_C))
	{
		if(!_aniState->getEnabled())
		{
			_aniState->setEnabled(true);
			_aniState->setLoop(true);
		}


		_aniState->addTime(evt.timeSinceLastFrame * variable);
		if(_aniState->getTimePosition() >= 25.0)
			variable =-1;
	}
	if(mKeyboard->isKeyDown(OIS::KC_X))
	{
		_aniState->setEnabled(false);
		_aniState = player->getAnimationState("Dancing");
	}
	if(mKeyboard->isKeyDown(OIS::KC_Z))
	{
		_aniState->setEnabled(false);
		_aniState = player->getAnimationState("InjuredWalk");
	}
	if(mKeyboard->isKeyDown(OIS::KC_F))
	{
		_aniState->setEnabled(false);
		_aniState = player->getAnimationState("Jabs");
	}
	if(!XboxControllers->GetState(0).error &&
		XboxControllers->GetState(0).Buttons.A)
	{

	}

	BtOgre::AnimatedMeshToShapeConverter converter(player);
	converter.setScale(playerNode->getScale());
	delete mCharacterShape;
	mCharacterShape = converter.createConvex();
	mCharacterBody->setCollisionShape(mCharacterShape);
	//mCharacterBody->getWorldTransform().getBasis().setEulerZYX(0,0,0);
	//mCharacterBody->applyCentralImpulse(mImpulse);
	//Update Bullet world.

	Globals::phyWorld->stepSimulation(evt.timeSinceLastFrame, 10);
	Globals::dbgdraw->setDebugMode(mKeyboard->isKeyDown(OIS::KC_F3));
	//if(mKeyboard->isKeyDown(OIS::KC_F3)) SCREENSHOT CODE
	//mWindow->writeContentsToTimestampedFile(Ogre::String("screenshot"),Ogre::String(".jpg"));
	Globals::dbgdraw->step();
	//for(unsigned int ij = 0;ij < mLoader->mPGHandles.size();ij++)
	//{
	//    mLoader->mPGHandles[ij]->update();
	//}

	return ret;
}
//-------------------------------------------------------------------------------------
void SampleApp::switchCamera(int idx)
{
	if (idx <= (int)mCamNames.size())
	{
		mSceneMgr->getEntity(mActiveCamera->getName() + Ogre::String("_debug"))->setVisible(true);
		mSceneMgr->getSceneNode(mActiveCamera->getName())->setPosition(mActiveCamera->getPosition());
		mSceneMgr->getSceneNode(mActiveCamera->getName())->setOrientation(mActiveCamera->getOrientation());
		mActiveCamera = mSceneMgr->getCamera(mCamNames[idx-1]);
		mWindow->getViewport(0)->setCamera(mActiveCamera);
		mCameraMan->setCamera(mActiveCamera);
		mSceneMgr->getEntity(mActiveCamera->getName() + Ogre::String("_debug"))->setVisible(false);
	}
}

//-------------------------------------------------------------------------------------
bool SampleApp::keyPressed( const OIS::KeyEvent &arg )
{
	if (mTrayMgr->isDialogVisible()) return true;   // don't process any more keys if dialog is up

	if (arg.key == OIS::KC_H || arg.key == OIS::KC_F1)   // toggle visibility of help dialog
	{
		if (!mTrayMgr->isDialogVisible()) mTrayMgr->showOkDialog("Help", mHelpInfo);
		else mTrayMgr->closeDialog();
	}
	if (arg.key == OIS::KC_0)   // toggle scenenode debug renderables
	{
		mSceneMgr->setDisplaySceneNodes(!mSceneMgr->getDisplaySceneNodes());
	}
	if (arg.key == OIS::KC_1)   // switch to camera 1
	{
		switchCamera(1);
	}
	if (arg.key == OIS::KC_2)   // switch to camera 2
	{
		switchCamera(2);
	}
	if (arg.key == OIS::KC_3)   // switch to camera 3
	{
		switchCamera(3);
	}
	if (arg.key == OIS::KC_4)   // switch to camera 4
	{
		switchCamera(4);
	}
	if (arg.key == OIS::KC_5)   // switch to camera 5
	{
		switchCamera(5);
	}
	if (arg.key == OIS::KC_6)   // switch to camera 6
	{
		switchCamera(6);
	}
	if (arg.key == OIS::KC_7)   // switch to camera 7
	{
		switchCamera(7);
	}
	if (arg.key == OIS::KC_8)   // switch to camera 8
	{
		switchCamera(8);
	}
	if (arg.key == OIS::KC_9)   // switch to camera 9
	{
		switchCamera(9);
	}
	if (arg.key == OIS::KC_MINUS)   // toggle fly/walk
	{
		playerNode->scale(Ogre::Vector3(0.5,0.5,0.5));
	}
	if (arg.key == OIS::KC_EQUALS)   // toggle fly/walk
	{
		playerNode->scale(Ogre::Vector3(2,2,2));
	}

	return BaseApplication::keyPressed( arg );
}

//-------------------------------------------------------------------------------------
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
	INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
#else
	int main(int argc, char *argv[])
#endif
	{
		// Create application object
		SampleApp app;

		try {
			app.go();
		} catch( Ogre::Exception& e ) {
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
			MessageBox( NULL, e.getFullDescription().c_str(), "An exception has occured!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
#else
			std::cerr << "An exception has occured: " <<
				e.getFullDescription().c_str() << std::endl;
#endif
		}

		return 0;
	}

#ifdef __cplusplus
}
#endif
